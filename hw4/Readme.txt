Example implementation of Decaf AST builder.	
Report errors to Yuxuan Shui and C. R. Ramakrishnan

README.txt:	this file
decaflexer.py	PLY/lex specification of Decaf tokens.
		Also defines "errorflag" used to signal error during scanning/parsing.
decafparser.py	PLY/yacc specification of Decaf grammar.
		The encoded grammar rules appear in the same order as in decaf manual.
		Defines "from_file" function that takes a file name
		and parses that file's contents. "from_file" returns
		True if no error, and False if error.

ast.py		Class structure and functions for AST construction.

decafch.py	Driver: processes arguments and gets file name to pass
		to decafparser.from_file
		Decaf programs are assumed to be in files with ".decaf" suffix.
		Argument given to decafch may omit this suffix; e.g.
				python decafch test
		will read from test.decaf.

typechecker.py
		Input for this file is parse tree which is generated by ast.py
		output is boolean variable indicating whether the parse tree is type check valid
		
		typechecker.py main method is called from decafch.py, 
		main in turn calls checkClass method to typeChecks each class.
		checkClass method typeCheckshecks the method and constructors in the class.
		checkMethod and checkConstructor typeChecks the body.
		checkBody method typeChecks all the statements in the body.
		checkStatement calls corresponding check method for each type of statements
		Each type of check statement invokes checkExpr() method
		In checkExpr method actual typeCheck validation occurs depending on the type of expression
		(Ex: Binary, Unary, Method-invocation etc.)
		In checkExpr if a failure in type happens, corresponding error messages are displayed.
		
		
		For name resolution of methods and new objects we check the current class for the existence,
		if not found super class is checked and so on..
		
		There are two utility methods to verify whether one type is subtype of other.
		